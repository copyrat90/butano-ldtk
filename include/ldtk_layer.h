// SPDX-FileCopyrightText: Copyright 2025 Guyeon Yu <copyrat90@gmail.com>
// SPDX-License-Identifier: Zlib

#pragma once

#include "ldtk_layer_definition.h"
#include "ldtk_tileset_definition.h"

#include "ldtk_entity.h"
#include "ldtk_gen_idents_fwd.h"
#include "ldtk_gen_iids_fwd.h"
#include "ldtk_int_grid_base.h"
#include "ldtk_layer_type.h"
#include "ldtk_tile_grid_base.h"

#include <bn_assert.h>
#include <bn_fixed.h>
#include <bn_point.h>
#include <bn_size.h>
#include <bn_span.h>

#include <algorithm>

namespace ldtk
{

class layer
{
public:
    /// @cond DO_NOT_DOCUMENT
    constexpr layer(const layer_definition& def, const tileset_definition* tileset_def, const bn::size& c_size,
                    const bn::point& px_total_offset, const tile_grid_base* auto_layer_tiles,
                    const tile_grid_base* grid_tiles, const int_grid_base* int_grid,
                    const bn::span<const entity>& entity_instances, gen::layer_iid iid, bool visible)
        : _def(def), _tileset_def(tileset_def), _c_size(c_size), _px_total_offset(px_total_offset),
          _auto_layer_tiles(auto_layer_tiles), _grid_tiles(grid_tiles), _int_grid(int_grid),
          _entity_instances(entity_instances), _iid(iid), _visible(visible)
    {
    }
    /// @endcond

    /// @brief Deleted copy constructor.
    constexpr layer(const layer&) = delete;

    /// @brief Deleted copy assignment operator.
    constexpr layer& operator=(const layer&) = delete;

    /// @brief Defaulted move constructor.
    constexpr layer(layer&&) = default;

    /// @brief Defaulted move assignment operator.
    constexpr layer& operator=(layer&&) = default;

public:
    /// @brief Linear searches an entity with its Instance id.
    /// @note Not finding the entity errors out;
    /// You should @b never use entity IIDs that's for other layer instance.
    /// @param iid Instance id of the entity to search for.
    /// @return Reference to the found entity.
    [[nodiscard]] constexpr auto find_entity(gen::entity_iid iid) const -> const entity&
    {
        auto iter = std::ranges::find_if(_entity_instances, [iid](const entity& et) { return et.iid() == iid; });
        BN_ASSERT(iter != _entity_instances.end(), "Entity not found with (gen::entity_iid)", (int)iid,
                  " - perhaps it's an entity of different layer instance");

        return *iter;
    }

public:
    /// @brief Reference to the Layer definition
    [[nodiscard]] constexpr auto def() const -> const layer_definition&
    {
        return _def;
    }

    /// @brief (Only *Tile layers, Auto-layers*) Reference to the corresponding Tileset
    [[nodiscard]] constexpr auto tileset_def() const -> const tileset_definition*
    {
        return _tileset_def;
    }

    /// @brief Grid-based size
    [[nodiscard]] constexpr auto c_size() const -> const bn::size&
    {
        return _c_size;
    }

    /// @brief Grid-based width
    [[nodiscard]] constexpr auto c_width() const -> int
    {
        return _c_size.width();
    }

    /// @brief Grid-based height
    [[nodiscard]] constexpr auto c_height() const -> int
    {
        return _c_size.height();
    }

    /// @brief Grid size
    [[nodiscard]] constexpr auto grid_size() const -> int
    {
        return def().grid_size();
    }

    /// @brief Layer definition identifier
    [[nodiscard]] constexpr auto identifier() const -> gen::layer_ident
    {
        return def().identifier();
    }

    /// @brief Layer opacity as Fixed [0-1]
    [[nodiscard]] constexpr auto opacity() const -> bn::fixed
    {
        return def().display_opacity();
    }

    /// @brief Total layer pixel offset, including both instance and definition offsets.
    [[nodiscard]] constexpr auto px_total_offset() const -> const bn::point&
    {
        return _px_total_offset;
    }

    /// @brief Total layer X pixel offset, including both instance and definition offsets.
    [[nodiscard]] constexpr auto px_total_offset_x() const -> int
    {
        return px_total_offset().x();
    }

    /// @brief Total layer Y pixel offset, including both instance and definition offsets.
    [[nodiscard]] constexpr auto px_total_offset_y() const -> int
    {
        return px_total_offset().y();
    }

    /// @brief Layer type
    [[nodiscard]] constexpr auto type() const -> layer_type
    {
        return def().type();
    }

    /// @brief (Only *Auto-layers*) An array containing all tiles generated by Auto-layer rules.
    /// The array is already sorted in display order (ie. 1st tile is beneath 2nd, which is beneath 3rd etc.).
    /// @note if multiple tiles are stacked in the same cell as the result of different rules,
    /// all tiles behind opaque ones will be discarded.
    [[nodiscard]] constexpr auto auto_layer_tiles() const -> const tile_grid_base*
    {
        return _auto_layer_tiles;
    }

    /// @brief (Only *Tile layers*)
    [[nodiscard]] constexpr auto grid_tiles() const -> const tile_grid_base*
    {
        return _grid_tiles;
    }

    /// @brief (Only *IntGrid layers*) A list of all values in the IntGrid layer. \n
    /// 0 means "empty cell" and IntGrid values start at 1. \n
    /// The size is `c_width()` x `c_height()` cells.
    [[nodiscard]] constexpr auto int_grid() const -> const int_grid_base*
    {
        return _int_grid;
    }

    /// @brief (Only *Entity layers*)
    [[nodiscard]] constexpr auto entity_instances() const -> const bn::span<const entity>&
    {
        return _entity_instances;
    }

    /// @brief Unique layer instance id
    [[nodiscard]] constexpr auto iid() const -> gen::layer_iid
    {
        return _iid;
    }

    /// @brief Layer instance visibility
    [[nodiscard]] constexpr auto visible() const -> bool
    {
        return _visible;
    }

private:
    const layer_definition& _def;
    const tileset_definition* _tileset_def;

    bn::size _c_size;
    bn::point _px_total_offset;

    const tile_grid_base* _auto_layer_tiles;
    const tile_grid_base* _grid_tiles;
    const int_grid_base* _int_grid;

    bn::span<const entity> _entity_instances;
    gen::layer_iid _iid;

    bool _visible;
};

} // namespace ldtk

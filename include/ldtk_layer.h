#pragma once

#include "ldtk_layer_definition.h"
#include "ldtk_tileset_definition.h"

#include "ldtk_entity.h"
#include "ldtk_gen_ident_fwd.h"
#include "ldtk_gen_iid_fwd.h"
#include "ldtk_int_grid_base.h"
#include "ldtk_layer_type.h"
#include "ldtk_tile_grid_base.h"

#include <bn_assert.h>
#include <bn_fixed.h>
#include <bn_span.h>

#include <algorithm>

namespace ldtk
{

class layer
{
public:
    constexpr layer(const layer_definition& def, const tileset_definition* tileset_def, int c_height, int c_width,
                    int px_total_offset_x, int px_total_offset_y, const tile_grid_base* auto_layer_tiles,
                    const bn::span<const entity>& entity_instances, const tile_grid_base* grid_tiles, gen::iid iid,
                    const int_grid_base* int_grid, bool visible)
        : _def(def), _tileset_def(tileset_def), _c_height(c_height), _c_width(c_width),
          _px_total_offset_x(px_total_offset_x), _px_total_offset_y(px_total_offset_y),
          _auto_layer_tiles(auto_layer_tiles), _entity_instances(entity_instances), _grid_tiles(grid_tiles), _iid(iid),
          _int_grid(int_grid), _visible(visible)
    {
    }

public:
    /// @brief Linear searches an entity with its Instance id.
    /// @note Not finding the entity errors out;
    /// You should @b never use non-entity IID nor unrelated one in current context.
    /// @param iid Instance id of the entity to search for.
    /// @return Reference to the found entity.
    [[nodiscard]] constexpr auto find_entity(gen::iid iid) const -> const entity&
    {
        auto iter = std::ranges::find_if(_entity_instances, [iid](const entity& et) { return et.iid() == iid; });
        BN_ASSERT(iter != _entity_instances.end(), "Entity not found with (gen::iid)", (int)iid,
                  " - it's a non-entity or unrelated IID");

        return *iter;
    }

public:
    /// @brief Reference to the Layer definition
    [[nodiscard]] constexpr auto def() const -> const layer_definition&
    {
        return _def;
    }

    /// @brief (Only *Tile layers, Auto-layers*) Reference to the corresponding Tileset
    [[nodiscard]] constexpr auto tileset_def() const -> const tileset_definition*
    {
        return _tileset_def;
    }

    /// @brief Grid-based height
    [[nodiscard]] constexpr auto c_height() const -> int
    {
        return _c_height;
    }

    /// @brief Grid-based width
    [[nodiscard]] constexpr auto c_width() const -> int
    {
        return _c_width;
    }

    /// @brief Grid size
    [[nodiscard]] constexpr auto grid_size() const -> int
    {
        return def().grid_size();
    }

    /// @brief Layer definition identifier
    [[nodiscard]] constexpr auto identifier() const -> gen::ident
    {
        return def().identifier();
    }

    /// @brief Layer opacity as Fixed [0-1]
    [[nodiscard]] constexpr auto opacity() const -> bn::fixed
    {
        return def().display_opacity();
    }

    /// @brief Total layer X pixel offset, including both instance and definition offsets.
    [[nodiscard]] constexpr auto px_total_offset_x() const -> int
    {
        return _px_total_offset_x;
    }

    /// @brief Total layer Y pixel offset, including both instance and definition offsets.
    [[nodiscard]] constexpr auto px_total_offset_y() const -> int
    {
        return _px_total_offset_y;
    }

    /// @brief Layer type
    [[nodiscard]] constexpr auto type() const -> layer_type
    {
        return def().type();
    }

    /// @brief (Only *Auto-layers*) An array containing all tiles generated by Auto-layer rules.
    /// The array is already sorted in display order (ie. 1st tile is beneath 2nd, which is beneath 3rd etc.).
    /// @note if multiple tiles are stacked in the same cell as the result of different rules,
    /// all tiles behind opaque ones will be discarded.
    [[nodiscard]] constexpr auto auto_layer_tiles() const -> const tile_grid_base*
    {
        return _auto_layer_tiles;
    }

    /// @brief (Only *Entity layers*)
    [[nodiscard]] constexpr auto entity_instances() const -> const bn::span<const entity>&
    {
        return _entity_instances;
    }

    /// @brief (Only *Tile layers*)
    [[nodiscard]] constexpr auto grid_tiles() const -> const tile_grid_base*
    {
        return _grid_tiles;
    }

    /// @brief Unique project identifier
    [[nodiscard]] constexpr auto iid() const -> gen::iid
    {
        return _iid;
    }

    /// @brief (Only *IntGrid layers*) A list of all values in the IntGrid layer. \n
    /// 0 means "empty cell" and IntGrid values start at 1. \n
    /// The size is `c_width()` x `c_height()` cells.
    [[nodiscard]] constexpr auto int_grid() const -> const int_grid_base*
    {
        return _int_grid;
    }

    /// @brief Layer instance visibility
    [[nodiscard]] constexpr auto visible() const -> bool
    {
        return _visible;
    }

private:
    const layer_definition& _def;
    const tileset_definition* _tileset_def;

    int _c_height;
    int _c_width;

    int _px_total_offset_x;
    int _px_total_offset_y;

    const tile_grid_base* _auto_layer_tiles;
    bn::span<const entity> _entity_instances;
    const tile_grid_base* _grid_tiles;
    gen::iid _iid;
    const int_grid_base* _int_grid;

    bool _visible;
};

} // namespace ldtk

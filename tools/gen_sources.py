# SPDX-FileCopyrightText: Copyright 2025 Guyeon Yu <copyrat90@gmail.com>
# SPDX-License-Identifier: Zlib

from models import *
from convert_exceptions import *
from abc import ABCMeta, abstractmethod
from io import TextIOWrapper
from datetime import datetime
from pathlib import Path
from enum import Enum
from typing import Dict, DefaultDict, List, NamedTuple, Tuple, Optional, Generator


class GenSource(metaclass=ABCMeta):
    @staticmethod
    @abstractmethod
    def base_file_path() -> Path:
        pass

    def __init__(self):
        self.__include_header_files: dict[str, bool] = {}
        self.add_include("bn_span.h", is_system_header=True)

    def add_include(self, include_header_filename: str, is_system_header: bool = False):
        if not is_system_header and not include_header_filename.endswith(".h"):
            raise Exception(f"{include_header_filename} does not end with '.h'")
        self.__include_header_files[include_header_filename] = is_system_header

    def write(self, build_folder_path: Path):
        source_path: Path = build_folder_path.joinpath(self._sub_folder()).joinpath(
            self.base_file_path()
        )
        try:
            with source_path.open("w", encoding="utf-8") as source:
                self.__write_heading(source)
                self.__write_includes(source)
                self.__write_namespace_open(source)
                self._write_contents(source)
                self.__write_namespace_close(source)
        except:
            source_path.unlink(missing_ok=True)
            raise

    @abstractmethod
    def _write_contents(self, source: TextIOWrapper):
        pass

    @staticmethod
    def _sub_folder() -> Path:
        return Path("src")

    @staticmethod
    def _sub_namespace() -> str:
        return "::gen"

    @staticmethod
    def _write_additional_heading(source: TextIOWrapper):
        pass

    def __write_heading(self, source: TextIOWrapper):
        source.write(f"// Generated by `butano_ldtk.py` in {datetime.now()}\n")
        source.write("//\n")
        source.write(
            "// DO NOT edit this file directly - changes will be overwritten!\n\n"
        )
        self._write_additional_heading(source)

    def __write_includes(self, source: TextIOWrapper):
        for (
            include_header_filename,
            is_system_header,
        ) in self.__include_header_files.items():
            if is_system_header:
                source.write(f"#include <{include_header_filename}>\n")
            else:
                source.write(f'#include "{include_header_filename}"\n')
        source.write("\n")

    def __write_namespace_open(self, source: TextIOWrapper):
        source.write(f"namespace ldtk{self._sub_namespace()}\n")
        source.write("{\n\n")

    def __write_namespace_close(self, source: TextIOWrapper):
        source.write("\n")
        source.write(f"}} // namespace ldtk{self._sub_namespace()}\n")


class GenPrivSource(GenSource):
    @staticmethod
    def _sub_namespace() -> str:
        return "::gen::priv"


class GenHeader(GenSource):
    @staticmethod
    def _sub_folder() -> Path:
        return Path("include")

    @staticmethod
    def _write_additional_heading(source: TextIOWrapper):
        source.write("#pragma once\n\n")


class GenPrivHeader(GenHeader):
    @staticmethod
    def _sub_namespace() -> str:
        return "::gen::priv"


class IdentsHeader(GenHeader):
    class TilesetIdent(NamedTuple):
        tileset_ident: str

    class LevelIdent(NamedTuple):
        level_ident: str

    class LevelFieldIdent(NamedTuple):
        field_ident: str

    class LayerIdent(NamedTuple):
        layer_ident: str

    class LayerIntGridValueIdent(NamedTuple):
        layer_ident: str
        int_grid_value_ident: str

    class LayerIntGridValueGroupIdent(NamedTuple):
        layer_ident: str
        int_grid_value_group_ident: str

    class EntityIdent(NamedTuple):
        entity_ident: str

    class EntityFieldIdent(NamedTuple):
        entity_ident: str
        field_ident: str

    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_idents.h")

    def __init__(self):
        super().__init__()
        self.add_include("ldtk_gen_idents_fwd.h")

        self.tileset_idents: List[IdentsHeader.TilesetIdent] = []
        self.level_idents: List[IdentsHeader.LevelIdent] = []
        self.level_field_idents: List[IdentsHeader.LevelFieldIdent] = []
        self.layer_idents: List[IdentsHeader.LayerIdent] = []
        self.layer_int_grid_value_idents: List[
            Tuple[IdentsHeader.LayerIntGridValueIdent, int]
        ] = []
        self.layer_int_grid_value_group_idents: List[
            Tuple[IdentsHeader.LayerIntGridValueGroupIdent, int]
        ] = []
        self.entity_idents: List[IdentsHeader.EntityIdent] = []
        self.entity_field_idents: List[Tuple[IdentsHeader.EntityFieldIdent, int]] = []

    def add_tileset_idents(self, tileset_defs: List[LdtkJson.TilesetDefinition]):
        for tileset_def in tileset_defs:
            key = IdentsHeader.TilesetIdent(tileset_def.identifier)
            self.tileset_idents.append(key)

    def add_level_idents(self, levels: List[LdtkJson.Level]):
        for level in levels:
            key = IdentsHeader.LevelIdent(level.identifier)
            self.level_idents.append(key)

    def add_level_field_idents(self, level_field_defs: List[LdtkJson.FieldDefinition]):
        for field_def in level_field_defs:
            key = IdentsHeader.LevelFieldIdent(field_def.identifier)
            self.level_field_idents.append(key)

    def add_layer_idents(self, layer_defs: List[LdtkJson.LayerDefinition]):
        for layer_def in layer_defs:
            key = IdentsHeader.LayerIdent(layer_def.identifier)
            self.layer_idents.append(key)

    def add_layer_int_grid_value_idents(
        self, layer_ident: str, int_grid_values: List[LdtkJson.IntGridValueDefinition]
    ):
        for idx, int_grid_value_def in enumerate(int_grid_values):
            if int_grid_value_def.identifier is None:
                continue
            key = IdentsHeader.LayerIntGridValueIdent(
                layer_ident, int_grid_value_def.identifier
            )
            self.layer_int_grid_value_idents.append((key, idx + 1))

    def add_layer_int_grid_value_group_idents(
        self,
        layer_ident: str,
        int_grid_value_groups: List[LdtkJson.IntGridValueGroupDefinition],
    ):
        for idx, int_grid_value_group_def in enumerate(int_grid_value_groups):
            if int_grid_value_group_def.identifier is None:
                continue
            key = IdentsHeader.LayerIntGridValueGroupIdent(
                layer_ident, int_grid_value_group_def.identifier
            )
            self.layer_int_grid_value_group_idents.append((key, idx + 1))

    def add_entity_idents(self, entity_defs: List[LdtkJson.EntityDefinition]):
        for entity_def in entity_defs:
            key = IdentsHeader.EntityIdent(entity_def.identifier)
            self.entity_idents.append(key)

    def add_entity_field_idents(
        self, entity_ident: str, entity_field_defs: List[LdtkJson.FieldDefinition]
    ):
        for idx, field_def in enumerate(entity_field_defs):
            key = IdentsHeader.EntityFieldIdent(entity_ident, field_def.identifier)
            self.entity_field_idents.append((key, idx))

    def _write_contents(self, source: TextIOWrapper):
        source.write("enum class tileset_ident {\n")
        for ident in self.tileset_idents:
            source.write(f"    {ident.tileset_ident},\n")
        source.write("};\n\n")

        source.write("enum class level_ident {\n")
        for ident in self.level_idents:
            source.write(f"    {ident.level_ident},\n")
        source.write("};\n\n")

        source.write("enum class level_field_ident {\n")
        for ident in self.level_field_idents:
            source.write(f"    {ident.field_ident},\n")
        source.write("};\n\n")

        source.write("enum class layer_ident {\n")
        for ident in self.layer_idents:
            source.write(f"    {ident.layer_ident},\n")
        source.write("};\n\n")

        source.write("enum class layer_int_grid_value_ident {\n")
        for ident, idx in self.layer_int_grid_value_idents:
            source.write(
                f"    LAYER_{ident.layer_ident}_INT_GRID_VALUE_{ident.int_grid_value_ident} = {idx},\n"
            )
        source.write("};\n\n")

        source.write("enum class layer_int_grid_value_group_ident {\n")
        for ident, idx in self.layer_int_grid_value_group_idents:
            source.write(
                f"    LAYER_{ident.layer_ident}_INT_GRID_VALUE_GROUP_{ident.int_grid_value_group_ident} = {idx},\n"
            )
        source.write("};\n\n")

        source.write("enum class entity_ident {\n")
        for ident in self.entity_idents:
            source.write(f"    {ident.entity_ident},\n")
        source.write("};\n\n")

        source.write("enum class entity_field_ident {\n")
        for ident, idx in self.entity_field_idents:
            source.write(
                f"    ENTITY_{ident.entity_ident}_FIELD_{ident.field_ident} = {idx},\n"
            )
        source.write("};\n")


class IidsHeader(GenHeader):
    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_iids.h")

    def __init__(self):
        super().__init__()
        self.add_include("ldtk_gen_iids_fwd.h")

        self.iids: DefaultDict[str, Set[str]] = DefaultDict(set)
        """Context -> Set[iid value]"""

    def add_iid(self, iid: str, context: str):
        self.iids[context.lower()].add(iid.replace("-", "_"))

    def _write_contents(self, source: TextIOWrapper):
        num_value = 0
        for context, iids in self.iids.items():
            source.write(f"enum class {context}_iid {{\n")
            for iid in iids:
                source.write(f"    _{iid} = {num_value},\n")
                num_value += 1
            source.write("};\n\n")


class TagsHeader(GenHeader):
    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_tags.h")

    def __init__(self):
        super().__init__()
        self.add_include("ldtk_gen_tags_fwd.h")

        self.tags: DefaultDict[str, Set[str]] = DefaultDict(set)
        """Context -> Set[tag value]"""

    def add_tag(self, tag: str, context: str):
        self.tags[context.lower()].add(tag)

    def _write_contents(self, source: TextIOWrapper):
        for context, tags in self.tags.items():
            source.write(f"enum class {context}_tag {{\n")
            for tag in tags:
                source.write(f"    {tag},\n")
            source.write("};\n\n")


class EnumsHeader(GenHeader):
    class EnumInfo(NamedTuple):
        storage_bits: int
        enum_values: List[str]

    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_enums.h")

    def __init__(self):
        super().__init__()
        self.add_include("cstdint", is_system_header=True)

        self.enums: Dict[str, EnumsHeader.EnumInfo] = {}
        """Enum identifier -> enum info"""

    def add_enum(self, enum_def: LdtkJson.EnumDefinition):
        enum_values = [val_def.id for val_def in enum_def.values]
        self.enums[enum_def.identifier] = EnumsHeader.EnumInfo(
            8 if len(enum_values) < 256 else 16 if len(enum_values) < 65536 else 32,
            enum_values,
        )

    def _write_contents(self, source: TextIOWrapper):
        for enum_ident, enum_info in self.enums.items():
            source.write(
                f"enum class {enum_ident} : std::uint{enum_info.storage_bits}_t {{\n"
            )
            for val in enum_info.enum_values:
                source.write(f"    {val},\n")
            source.write("};\n\n")


class DefinitionsHeader(GenPrivHeader):
    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_definitions.h")

    def __init__(self):
        super().__init__()
        self.add_include("ldtk_definitions.h")
        self.add_include("ldtk_gen_priv_entity_definitions.h")
        self.add_include("ldtk_gen_priv_layer_definitions.h")
        self.add_include("ldtk_gen_priv_level_field_definitions.h")
        self.add_include("ldtk_gen_priv_tileset_definitions.h")

    def _write_contents(self, source: TextIOWrapper):
        source.write("inline constexpr const definitions gen_priv_definitions(\n")
        source.write("    gen_priv_entity_definitions,\n")
        source.write("    gen_priv_layer_definitions,\n")
        source.write("    gen_priv_level_field_definitions,\n")
        source.write("    gen_priv_tileset_definitions\n")
        source.write(");\n")


class EntityDefinitionsHeader(GenPrivHeader):
    class Entity(NamedTuple):
        size: Size
        identifier: str
        pivot: FixedPoint
        uid: int
        max_count: int
        limit_scope: str

    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_entity_definitions.h")

    def __init__(self):
        super().__init__()
        self.add_include("ldtk_entity_definition.h")
        self.add_include("ldtk_gen_priv_entity_field_definitions.h")
        self.add_include("ldtk_gen_priv_entity_definitions_tags.h")
        self.add_include("ldtk_gen_idents.h")
        self.add_include("ldtk_gen_tags.h")

        self.entities: List[EntityDefinitionsHeader.Entity] = []

    def add_entity(self, entity_def: LdtkJson.EntityDefinition):
        self.entities.append(
            EntityDefinitionsHeader.Entity(
                Size(entity_def.width, entity_def.height),
                entity_def.identifier,
                FixedPoint(entity_def.pivot_x, entity_def.pivot_y),
                entity_def.uid,
                entity_def.max_count,
                entity_def.limit_scope.name,
            )
        )

    def _write_contents(self, source: TextIOWrapper):
        if len(self.entities) == 0:
            source.write(
                "inline constexpr bn::span<const entity_definition> gen_priv_entity_definitions;\n"
            )
        else:
            source.write(
                "inline constexpr const entity_definition gen_priv_entity_definitions[] {\n"
            )
            for entity in self.entities:
                source.write("    entity_definition(\n")
                source.write(f"        {entity.size},\n")
                source.write(f"        entity_ident::{entity.identifier},\n")
                source.write(f"        {entity.pivot},\n")
                source.write(f"        {entity.uid},\n")
                source.write(
                    f"        gen_priv_entity_{entity.identifier}_field_definitions,\n"
                )
                source.write(f"        gen_priv_entity_{entity.identifier}_tags,\n")
                source.write(f"        {entity.max_count},\n")
                source.write(
                    f"        entity_definition::limit_scope_kind::{entity.limit_scope}\n"
                )
                source.write("    ),\n")
            source.write("};\n")


class EntityFieldDefinitionsHeader(GenPrivHeader):
    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_entity_field_definitions.h")

    def __init__(self):
        super().__init__()
        self.add_include("ldtk_field_definition.h")
        self.add_include("ldtk_gen_idents.h")
        self.add_include("ldtk_gen_enums.h")

        self.entity_fields: Dict[str, List[FieldDef]] = {}
        """Entity identifier -> entity's field list"""

    def add_entity(self, entity_def: LdtkJson.EntityDefinition):
        result: List[FieldDef] = []
        for field_def in entity_def.field_defs:
            parsed_type = parse_field_type(
                field_def.type, field_def.can_be_null, field_def.min, field_def.max
            )
            result.append(
                FieldDef(
                    parsed_type.field_type,
                    field_def.is_array,
                    parsed_type.enum_type,
                    field_def.can_be_null,
                    field_def.identifier,
                    field_def.uid,
                    (
                        field_def.array_min_length
                        if field_def.array_min_length is not None
                        else -1
                    ),
                    (
                        field_def.array_max_length
                        if field_def.array_max_length is not None
                        else -1
                    ),
                )
            )
        self.entity_fields[entity_def.identifier] = result

    def _write_contents(self, source: TextIOWrapper):
        for entity_ident, field_defs in self.entity_fields.items():
            if len(field_defs) == 0:
                source.write(
                    f"inline constexpr bn::span<const field_definition> gen_priv_entity_{entity_ident}_field_definitions;\n\n"
                )
            else:
                source.write(
                    f"inline constexpr const field_definition gen_priv_entity_{entity_ident}_field_definitions[] {{\n"
                )
                for field in field_defs:
                    source.write("    field_definition(\n")
                    source.write(f"        field_type::{field.field_type},\n")
                    source.write(f"        {str(field.is_array).lower()},\n")
                    source.write(
                        f'        {f"bn::type_id<{field.enum_type}>()" if field.enum_type is not None else "bn::nullopt"},\n'
                    )
                    source.write(
                        f'        {"true" if field.can_be_null else "false"},\n'
                    )
                    source.write(
                        f"        entity_field_ident::ENTITY_{entity_ident}_FIELD_{field.identifier},\n"
                    )
                    source.write(f"        {field.uid},\n")
                    source.write(f"        {field.array_min_length},\n")
                    source.write(f"        {field.array_max_length}\n")
                    source.write("    ),\n")
                source.write("};\n\n")


class EntityDefinitionsTagsHeader(GenPrivHeader):
    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_entity_definitions_tags.h")

    def __init__(self):
        super().__init__()
        self.add_include("ldtk_gen_tags.h")

        self.tags: Dict[str, List[str]] = {}
        """Entity identifier -> List[tag]"""

    def add_entity(self, entity_def: LdtkJson.EntityDefinition):
        self.tags[entity_def.identifier] = entity_def.tags

    def _write_contents(self, source: TextIOWrapper):
        for entity_ident, tags in self.tags.items():
            if len(tags) == 0:
                source.write(
                    f"inline constexpr bn::span<const entity_tag> gen_priv_entity_{entity_ident}_tags;\n\n"
                )
            else:
                source.write(
                    f"inline constexpr const entity_tag gen_priv_entity_{entity_ident}_tags[] {{\n"
                )
                for tag in tags:
                    source.write(f"    entity_tag::{tag},\n")
                source.write("};\n\n")


class LayerDefinitionsHeader(GenPrivHeader):
    class LayerType(Enum):
        INT_GRID = "IntGrid"
        ENTITIES = "Entities"
        TILES = "Tiles"
        AUTO_LAYER = "AutoLayer"

    class Layer(NamedTuple):
        layer_type: str
        display_opacity: float
        grid_size: int
        identifier: str
        parallax_factor_x: float
        parallax_factor_y: float
        uid: int

    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_layer_definitions.h")

    def __init__(self):
        super().__init__()
        self.add_include("ldtk_layer_definition.h")
        self.add_include("ldtk_gen_idents.h")
        self.add_include("ldtk_gen_priv_layer_definitions_int_grid_values.h")
        self.add_include("ldtk_gen_priv_layer_definitions_int_grid_value_groups.h")

        self.layers: List[LayerDefinitionsHeader.Layer] = []

    def add_layer(self, layer_def: LdtkJson.LayerDefinition):
        self.layers.append(
            LayerDefinitionsHeader.Layer(
                LayerDefinitionsHeader.LayerType(layer_def.type).name,
                layer_def.display_opacity,
                layer_def.grid_size,
                layer_def.identifier,
                layer_def.parallax_factor_x,
                layer_def.parallax_factor_y,
                layer_def.uid,
            )
        )

    def _write_contents(self, source: TextIOWrapper):
        if len(self.layers) == 0:
            source.write(
                "inline constexpr bn::span<const layer_definition> gen_priv_layer_definitions;\n"
            )
        else:
            source.write(
                "inline constexpr const layer_definition gen_priv_layer_definitions[] {\n"
            )
            for layer in self.layers:
                source.write("    layer_definition(\n")
                source.write(f"        layer_type::{layer.layer_type},\n")
                source.write(f"        {layer.display_opacity},\n")
                source.write(f"        {layer.grid_size},\n")
                source.write(f"        layer_ident::{layer.identifier},\n")
                source.write(
                    f"        gen_priv_layer_{layer.identifier}_definition_int_grid_values,\n"
                )
                source.write(
                    f"        gen_priv_layer_{layer.identifier}_definition_int_grid_value_groups,\n"
                )
                source.write(f"        {layer.parallax_factor_x},\n")
                source.write(f"        {layer.parallax_factor_y},\n")
                source.write(f"        {layer.uid}\n")
                source.write("    ),\n")
            source.write("};\n")


class LayerDefinitionsIntGridValuesHeader(GenPrivHeader):
    class IntGridValueInfo(NamedTuple):
        color: Color
        group_uid: int
        identifier: Optional[str]
        value: int

    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_layer_definitions_int_grid_values.h")

    def __init__(self):
        super().__init__()
        self.add_include("ldtk_int_grid_value_info.h")
        self.add_include("ldtk_gen_idents.h")

        self.int_grid_values: Dict[
            str, List[LayerDefinitionsIntGridValuesHeader.IntGridValueInfo]
        ] = {}
        """Layer identifier -> int grid value info list"""

    def add_layer(self, layer_def: LdtkJson.LayerDefinition):
        layer_def.int_grid_values.sort(key=lambda v: v.value)

        self.int_grid_values[layer_def.identifier] = [
            LayerDefinitionsIntGridValuesHeader.IntGridValueInfo(
                Color(int_grid_value.color),
                int_grid_value.group_uid,
                int_grid_value.identifier,
                int_grid_value.value,
            )
            for int_grid_value in layer_def.int_grid_values
        ]

    def _write_contents(self, source: TextIOWrapper):
        for layer_ident, int_grid_values in self.int_grid_values.items():
            if len(int_grid_values) == 0:
                source.write(
                    f"inline constexpr bn::span<const int_grid_value_info> gen_priv_layer_{layer_ident}_definition_int_grid_values;\n\n"
                )
            else:
                source.write(
                    f"inline constexpr const int_grid_value_info gen_priv_layer_{layer_ident}_definition_int_grid_values[] {{\n"
                )
                for int_grid_value in int_grid_values:
                    source.write("    int_grid_value_info(\n")
                    source.write(f"        {int_grid_value.color},\n")
                    source.write(f"        {int_grid_value.group_uid},\n")
                    source.write(
                        f'        {f"layer_int_grid_value_ident::LAYER_{layer_ident}_INT_GRID_VALUE_{int_grid_value.identifier}" if int_grid_value.identifier is not None else "bn::nullopt"},\n'
                    )
                    source.write(f"        {int_grid_value.value}\n")
                    source.write("    ),\n")
                source.write("};\n\n")


class LayerDefinitionsIntGridValueGroupsHeader(GenPrivHeader):
    class IntGridValueGroupInfo(NamedTuple):
        identifier: Optional[str]
        uid: int

    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_layer_definitions_int_grid_value_groups.h")

    def __init__(self):
        super().__init__()
        self.add_include("ldtk_int_grid_value_group_info.h")
        self.add_include("ldtk_gen_idents.h")

        self.int_grid_value_groups: Dict[
            str, List[LayerDefinitionsIntGridValueGroupsHeader.IntGridValueGroupInfo]
        ] = {}
        """Layer identifier -> int grid value group info list"""

    def add_layer(self, layer_def: LdtkJson.LayerDefinition):
        layer_def.int_grid_values_groups.sort(key=lambda g: g.uid)

        self.int_grid_value_groups[layer_def.identifier] = [
            LayerDefinitionsIntGridValueGroupsHeader.IntGridValueGroupInfo(
                int_grid_value_group.identifier, int_grid_value_group.uid
            )
            for int_grid_value_group in layer_def.int_grid_values_groups
        ]

    def _write_contents(self, source: TextIOWrapper):
        for layer_ident, groups in self.int_grid_value_groups.items():
            if len(groups) == 0:
                source.write(
                    f"inline constexpr bn::span<const int_grid_value_group_info> gen_priv_layer_{layer_ident}_definition_int_grid_value_groups;\n\n"
                )
            else:
                source.write(
                    f"inline constexpr const int_grid_value_group_info gen_priv_layer_{layer_ident}_definition_int_grid_value_groups[] {{\n"
                )
                for group in groups:
                    source.write("    int_grid_value_group_info(\n")
                    source.write(
                        f'        {f"layer_int_grid_value_group_ident::LAYER_{layer_ident}_INT_GRID_VALUE_GROUP_{group.identifier}" if group.identifier is not None else "bn::nullopt"},\n'
                    )
                    source.write(f"        {group.uid}\n")
                    source.write("    ),\n")
                source.write("};\n\n")


class LevelFieldDefinitionsHeader(GenPrivHeader):
    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_level_field_definitions.h")

    def __init__(self, field_defs: List[LdtkJson.FieldDefinition]):
        super().__init__()
        self.add_include("ldtk_field_definition.h")
        self.add_include("ldtk_gen_idents.h")
        self.add_include("ldtk_gen_enums.h")

        self.level_fields: List[FieldDef] = []
        for field_def in field_defs:
            parsed_type = parse_field_type(
                field_def.type, field_def.can_be_null, field_def.min, field_def.max
            )
            self.level_fields.append(
                FieldDef(
                    parsed_type.field_type,
                    field_def.is_array,
                    parsed_type.enum_type,
                    field_def.can_be_null,
                    field_def.identifier,
                    field_def.uid,
                    (
                        field_def.array_min_length
                        if field_def.array_min_length is not None
                        else -1
                    ),
                    (
                        field_def.array_max_length
                        if field_def.array_max_length is not None
                        else -1
                    ),
                )
            )

    def _write_contents(self, source: TextIOWrapper):
        if len(self.level_fields) == 0:
            source.write(
                "inline constexpr bn::span<const field_definition> gen_priv_level_field_definitions;\n"
            )
        else:
            source.write(
                "inline constexpr const field_definition gen_priv_level_field_definitions[] {\n"
            )
            for field in self.level_fields:
                source.write(f"    field_definition(\n")
                source.write(f"        field_type::{field.field_type},\n")
                source.write(f"        {str(field.is_array).lower()},\n")
                source.write(
                    f'        {f"bn::type_id<{field.enum_type}>()" if field.enum_type is not None else "bn::nullopt"},\n'
                )
                source.write(f'        {"true" if field.can_be_null else "false"},\n')
                source.write(f"        level_field_ident::{field.identifier},\n")
                source.write(f"        {field.uid},\n")
                source.write(f"        {field.array_min_length},\n")
                source.write(f"        {field.array_max_length}\n")
                source.write(f"    ),\n")
            source.write("};\n")


class TilesetDefinitionsHeader(GenPrivHeader):
    class Tileset(NamedTuple):
        identifier: str
        tiles_count: int
        tags_source_enum_id: Optional[str]
        grid_size: int
        uid: int

    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_tileset_definitions.h")

    def __init__(self):
        super().__init__()
        self.add_include("ldtk_tileset_definition.h")
        self.add_include("ldtk_gen_priv_tileset_definitions_custom_datas.h")
        self.add_include("ldtk_gen_priv_tileset_definitions_enum_tags.h")
        self.add_include("ldtk_gen_priv_tileset_definitions_tags.h")
        self.add_include("ldtk_gen_idents.h")
        self.add_include("ldtk_gen_tags.h")
        self.add_include("ldtk_gen_enums.h")

        self.tilesets: List[TilesetDefinitionsHeader.Tileset] = []

    def add_tileset(
        self,
        tileset_def: LdtkJson.TilesetDefinition,
        tileset_infos: TilesetInfos,
        enum_infos: EnumInfos,
    ):
        self.add_include(
            f"bn_regular_bg_items_ldtk_gen_priv_tileset_{tileset_def.identifier}.h"
        )
        self.tilesets.append(
            TilesetDefinitionsHeader.Tileset(
                tileset_def.identifier,
                tileset_infos.get_tileset_used_tiles_count(tileset_def.uid),
                (
                    enum_infos.get_enum_name_with_uid(tileset_def.tags_source_enum_uid)
                    if tileset_def.tags_source_enum_uid is not None
                    else None
                ),
                tileset_def.tile_grid_size,
                tileset_def.uid,
            )
        )

    def _write_contents(self, source: TextIOWrapper):
        if len(self.tilesets) == 0:
            source.write(
                "inline constexpr bn::span<const tileset_definition> gen_priv_tileset_definitions;\n"
            )
        else:
            source.write(
                "inline constexpr const tileset_definition gen_priv_tileset_definitions[] {\n"
            )
            for tileset in self.tilesets:
                source.write("    tileset_definition(\n")
                source.write(
                    f"        bn::regular_bg_items::ldtk_gen_priv_tileset_{tileset.identifier},\n"
                )
                source.write(f"        {tileset.tiles_count},\n")
                source.write(
                    f"        gen_priv_tileset_{tileset.identifier}_custom_datas,\n"
                )
                source.write(
                    f"        gen_priv_tileset_{tileset.identifier}_enum_tags,\n"
                )
                source.write(f"        tileset_ident::{tileset.identifier},\n")
                source.write(f"        gen_priv_tileset_{tileset.identifier}_tags,\n")
                source.write(
                    f'        {f"bn::type_id<{tileset.tags_source_enum_id}>()" if tileset.tags_source_enum_id is not None else "bn::nullopt"},\n'
                )
                source.write(f"        {tileset.grid_size},\n")
                source.write(f"        {tileset.uid}\n")
                source.write("    ),\n")
            source.write("};\n")


class TilesetDefinitionsCustomDatasHeader(GenPrivHeader):
    class CustomData(NamedTuple):
        data: str
        tile_id: int

    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_tileset_definitions_custom_datas.h")

    def __init__(self):
        super().__init__()
        self.add_include("ldtk_tileset_custom_data.h")

        self.custom_datas: Dict[
            str, List[TilesetDefinitionsCustomDatasHeader.CustomData]
        ] = {}
        """Tileset identifier -> List[CustomData]"""

    def add_tileset(
        self, tileset_def: LdtkJson.TilesetDefinition, tileset_infos: TilesetInfos
    ):
        self.custom_datas[tileset_def.identifier] = [
            TilesetDefinitionsCustomDatasHeader.CustomData(
                custom_data.data,
                tileset_infos.get_tileset_used_tile_id_to_idx(
                    tileset_def.uid, custom_data.tile_id
                ),
            )
            for custom_data in tileset_def.custom_data
            if tileset_infos.get_tileset_is_used_tile_id(
                tileset_def.uid, custom_data.tile_id
            )
        ]

    def _write_contents(self, source: TextIOWrapper):
        for tileset_ident, custom_datas in self.custom_datas.items():
            if len(custom_datas) == 0:
                source.write(
                    f"inline constexpr bn::span<const tileset_custom_data> gen_priv_tileset_{tileset_ident}_custom_datas;\n\n"
                )
            else:
                source.write(
                    f"inline constexpr const tileset_custom_data gen_priv_tileset_{tileset_ident}_custom_datas[] {{\n"
                )
                for data in custom_datas:
                    source.write("    tileset_custom_data(\n")
                    source.write(f'        R"({data.data})",\n')
                    source.write(f"        {1 + data.tile_id}\n")
                    source.write("    ),\n")
                source.write("};\n\n")


class TilesetDefinitionsEnumTagsHeader(GenPrivHeader):
    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_tileset_definitions_enum_tags.h")

    def __init__(self):
        super().__init__()
        self.add_include("ldtk_tileset_enum_tag.h")
        self.add_include("ldtk_gen_priv_tileset_definitions_enum_tag_tile_indexes.h")

        self.enum_tags: Dict[str, List[str]] = {}
        """Tileset identifier -> List[enum value str]"""

    def add_tileset(self, tileset_def: LdtkJson.TilesetDefinition):
        self.enum_tags[tileset_def.identifier] = [
            enum_tag.enum_value_id for enum_tag in tileset_def.enum_tags
        ]

    def _write_contents(self, source: TextIOWrapper):
        for tileset_ident, enum_values in self.enum_tags.items():
            if len(enum_values) == 0:
                source.write(
                    f"inline constexpr bn::span<const tileset_enum_tag> gen_priv_tileset_{tileset_ident}_enum_tags;\n\n"
                )
            else:
                source.write(
                    f"inline constexpr const tileset_enum_tag gen_priv_tileset_{tileset_ident}_enum_tags[] {{\n"
                )
                for enum_val in enum_values:
                    source.write(
                        f"    tileset_enum_tag(gen_priv_tileset_{tileset_ident}_enum_value_{enum_val}_tag_tile_indexes),\n"
                    )
                source.write("};\n\n")


class TilesetDefinitionsEnumTagTileIndexesHeader(GenPrivHeader):
    class Key(NamedTuple):
        tileset_ident: str
        enum_value: str

    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_tileset_definitions_enum_tag_tile_indexes.h")

    def __init__(self):
        super().__init__()
        self.add_include("ldtk_tile_index.h")

        self.tile_indexes: Dict[
            TilesetDefinitionsEnumTagTileIndexesHeader.Key, List[int]
        ] = {}
        """(tileset ident, enum value str) -> List[tile idx]"""

    def add_tileset(
        self, tileset_def: LdtkJson.TilesetDefinition, tileset_infos: TilesetInfos
    ):
        for enum_tag in tileset_def.enum_tags:
            key = TilesetDefinitionsEnumTagTileIndexesHeader.Key(
                tileset_def.identifier, enum_tag.enum_value_id
            )
            self.tile_indexes[key] = [
                tileset_infos.get_tileset_used_tile_id_to_idx(tileset_def.uid, tile_id)
                for tile_id in enum_tag.tile_ids
                if tileset_infos.get_tileset_is_used_tile_id(tileset_def.uid, tile_id)
            ]

    def _write_contents(self, source: TextIOWrapper):
        for key, tile_indexes in self.tile_indexes.items():
            if len(tile_indexes) == 0:
                source.write(
                    f"inline constexpr bn::span<const tile_index> gen_priv_tileset_{key.tileset_ident}_enum_value_{key.enum_value}_tag_tile_indexes;\n\n"
                )
            else:
                source.write(
                    f"inline constexpr const tile_index gen_priv_tileset_{key.tileset_ident}_enum_value_{key.enum_value}_tag_tile_indexes[] {{"
                )
                for i, tile_idx in enumerate(tile_indexes):
                    if i % 16 == 0:
                        source.write("\n    ")
                    source.write(f"{1 + tile_idx}, ")
                source.write("\n};\n\n")


class TilesetDefinitionsTagsHeader(GenPrivHeader):
    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_tileset_definitions_tags.h")

    def __init__(self):
        super().__init__()
        self.add_include("ldtk_gen_tags.h")

        self.tags: Dict[str, List[str]] = {}
        """Tileset identifier -> List[tag]"""

    def add_tileset(self, tileset_def: LdtkJson.TilesetDefinition):
        self.tags[tileset_def.identifier] = tileset_def.tags

    def _write_contents(self, source: TextIOWrapper):
        for tileset_ident, tags in self.tags.items():
            if len(tags) == 0:
                source.write(
                    f"inline constexpr bn::span<const tileset_tag> gen_priv_tileset_{tileset_ident}_tags;\n\n"
                )
            else:
                source.write(
                    f"inline constexpr const tileset_tag gen_priv_tileset_{tileset_ident}_tags[] {{\n"
                )
                for tag in tags:
                    source.write(f"    tileset_tag::{tag},\n")
                source.write("};\n\n")


class LevelsHeader(GenPrivHeader):
    class LevelInfo(NamedTuple):
        bg_color: Color
        identifier: str
        iid: str
        px_size: Size
        uid: int
        world_depth: int
        world_coord: Point

    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_levels.h")

    def __init__(self, levels: List[LdtkJson.Level]):
        super().__init__()
        self.add_include("ldtk_level.h")
        self.add_include("ldtk_gen_idents.h")
        self.add_include("ldtk_gen_iids.h")
        self.add_include("ldtk_gen_priv_level_field_instances.h")
        self.add_include("ldtk_gen_priv_level_layer_instances.h")

        self.levels: List[LevelsHeader.LevelInfo] = [
            LevelsHeader.LevelInfo(
                Color(level.bg_color),
                level.identifier,
                level.iid.replace("-", "_"),
                Size(level.px_wid, level.px_hei),
                level.uid,
                level.world_depth,
                Point(level.world_x, level.world_y),
            )
            for level in levels
        ]

    def _write_contents(self, source: TextIOWrapper):
        if len(self.levels) == 0:
            source.write("inline constexpr bn::span<const level> gen_priv_levels;\n")
        else:
            source.write("inline constexpr const level gen_priv_levels[] {\n")
            for level in self.levels:
                source.write("    level(\n")
                source.write(f"        {level.bg_color},\n")
                source.write(
                    f"        gen_priv_level_{level.identifier}_field_instances,\n"
                )
                source.write(f"        level_ident::{level.identifier},\n")
                source.write(f"        level_iid::_{level.iid},\n")
                source.write(
                    f"        gen_priv_level_{level.identifier}_layer_instances,\n"
                )
                source.write(f"        {level.px_size},\n")
                source.write(f"        {level.uid},\n")
                source.write(f"        {level.world_depth},\n")
                source.write(f"        {level.world_coord}\n")
                source.write("    ),\n")
            source.write("};\n")


class LevelFieldInstancesHeader(GenPrivHeader):
    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_level_field_instances.h")

    @staticmethod
    def parent_type() -> str:
        return "level"

    def __init__(self):
        super().__init__()
        self.add_include("cstdint", is_system_header=True)
        self.add_include("ldtk_field.h")
        self.add_include(f"ldtk_gen_priv_{self.parent_type()}_field_definitions.h")
        self.add_include(f"ldtk_gen_priv_{self.parent_type()}_field_arrays.h")
        self.add_include("ldtk_gen_enums.h")
        self.add_include("ldtk_gen_idents.h")
        self.add_include("ldtk_gen_iids.h")

        self.fields: Dict[str, List[str]] = {}
        """Parent id -> List[field value]"""

    def add_fields(
        self,
        parent_id: str,
        fields: List[LdtkJson.FieldInstance],
        layer_iid_to_ident: Dict[str, str],
        level_iid_to_ident: Dict[str, str],
        field_def_lut: Dict[int, LdtkJson.FieldDefinition],
    ):
        result: List[str] = []
        for field in fields:
            match field.type:
                case "Int":
                    field_def = field_def_lut[field.def_uid]
                    int_type = "std::int16_t"
                    min = int(field_def.min) if field_def.min is not None else -32768
                    max = int(field_def.max) if field_def.max is not None else 32767
                    if 0 <= min and max <= 255:
                        int_type = "std::uint8_t"
                    elif -128 <= min and max <= 127:
                        int_type = "std::int8_t"
                    elif 0 <= min and max <= 65535:
                        int_type = "std::uint16_t"
                    elif -32768 <= min and max <= 32767:
                        int_type = "std::int16_t"
                    else:
                        int_type = "std::int32_t"

                    result.append(
                        f"({int_type})({field.value})"
                        if field.value is not None
                        else f"bn::optional<{int_type}>()"
                    )
                case "Float":
                    result.append(
                        f"bn::fixed({field.value})"
                        if field.value is not None
                        else "bn::optional<bn::fixed>()"
                    )
                case "Bool":
                    assert field.value is not None
                    result.append(str(field.value).lower())
                case "String" | "Multilines":
                    result.append(
                        f'bn::string_view(R"({field.value})")'
                        if field.value is not None
                        else "bn::optional<bn::string_view>()"
                    )
                case "Color":
                    assert field.value is not None
                    result.append(str(Color(field.value)))
                case str(t) if t.startswith("LocalEnum"):
                    parsed = parse_field_type(t, False, None, None)
                    assert parsed.enum_type is not None

                    if field.value is not None:
                        result.append(f"{parsed.enum_type}::{str(field.value)}")
                    else:
                        result.append(f"bn::optional<{parsed.enum_type}>()")
                case "EntityRef":
                    if field.value is not None:
                        entity_ref = LdtkJson.ReferenceToAnEntityInstance.from_dict(
                            field.value
                        )
                        result.append(
                            f"entity_ref(entity_iid::_{entity_ref.entity_iid.replace("-", "_")}, layer_ident::{layer_iid_to_ident[entity_ref.layer_iid]}, level_ident::{level_iid_to_ident[entity_ref.level_iid]})"
                        )
                    else:
                        result.append("bn::optional<entity_ref>()")
                case "Point":
                    if field.value is not None:
                        grid_point: LdtkJson.GridPoint = LdtkJson.GridPoint.from_dict(
                            field.value
                        )
                        result.append(f"bn::point({grid_point.cx}, {grid_point.cy})")
                    else:
                        result.append("bn::optional<bn::point>()")
                case str(t) if t.startswith("Array"):
                    result.append(
                        f"bn::span(gen_priv_{self.parent_type()}_{parent_id}_field_{field.identifier}_array)"
                    )
                case _:
                    raise UnsupportedFieldTypeException(field.type, f'"{parent_id}"')

        self.fields[parent_id] = result

    def _write_contents(self, source: TextIOWrapper):
        for parent_id, fields in self.fields.items():
            if len(fields) == 0:
                source.write(
                    f"inline constexpr bn::span<const field> gen_priv_{self.parent_type()}_{parent_id}_field_instances;\n\n"
                )
            else:
                source.write(
                    f"inline constexpr const field gen_priv_{self.parent_type()}_{parent_id}_field_instances[] {{\n"
                )
                for field_idx, field in enumerate(fields):
                    source.write("    field(\n")
                    self._write_definition(field_idx, parent_id, source)
                    source.write(f"        {field}\n")
                    source.write("    ),\n")
                source.write("};\n\n")

    def _write_definition(self, field_idx: int, parent_id: str, source: TextIOWrapper):
        source.write(
            f"        gen_priv_{self.parent_type()}_field_definitions[{field_idx}],\n"
        )


class LevelFieldArraysHeader(GenPrivHeader):
    class Key(NamedTuple):
        parent_id: str
        field_ident: str

    class Value(NamedTuple):
        element_type: str
        elements: List[str]

    ELEM_TYPE: Final[Dict[str, str]] = {
        "UINT_8_SPAN": "std::uint8_t",
        "INT_8_SPAN": "std::int8_t",
        "UINT_16_SPAN": "std::uint16_t",
        "INT_16_SPAN": "std::int16_t",
        "INT_32_SPAN": "std::int32_t",
        "FIXED_SPAN": "bn::fixed",
        "BOOL_SPAN": "bool",
        "STRING_SPAN": "bn::string_view",
        "COLOR_SPAN": "bn::color",
        "TYPED_ENUM_SPAN": "Enum",
        # "TILE_SPAN": "tile",
        "ENTITY_REF_SPAN": "entity_ref",
        "POINT_SPAN": "bn::point",
        "OPTIONAL_UINT_8_SPAN": "bn::optional<std::uint8_t>",
        "OPTIONAL_INT_8_SPAN": "bn::optional<std::int8_t>",
        "OPTIONAL_UINT_16_SPAN": "bn::optional<std::uint16_t>",
        "OPTIONAL_INT_16_SPAN": "bn::optional<std::int16_t>",
        "OPTIONAL_INT_32_SPAN": "bn::optional<std::int32_t>",
        "OPTIONAL_FIXED_SPAN": "bn::optional<bn::fixed>",
        "OPTIONAL_STRING_SPAN": "bn::optional<bn::string_view>",
        "OPTIONAL_TYPED_ENUM_SPAN": "bn::optional<Enum>",
        # "OPTIONAL_TILE_SPAN": "bn::optional<tile>",
        "OPTIONAL_ENTITY_REF_SPAN": "bn::optional<entity_ref>",
        "OPTIONAL_POINT_SPAN": "bn::optional<bn::point>",
    }

    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_level_field_arrays.h")

    @staticmethod
    def parent_type() -> str:
        return "level"

    def __init__(self):
        super().__init__()
        self.add_include("cstdint", is_system_header=True)
        self.add_include("bn_color.h", is_system_header=True)
        self.add_include("bn_fixed.h", is_system_header=True)
        self.add_include("bn_optional.h", is_system_header=True)
        self.add_include("bn_point.h", is_system_header=True)
        self.add_include("bn_string_view.h", is_system_header=True)
        self.add_include("ldtk_priv_typed_enum.h")
        self.add_include("ldtk_entity_ref.h")
        self.add_include("ldtk_gen_idents.h")
        self.add_include("ldtk_gen_iids.h")
        self.add_include("ldtk_gen_enums.h")

        self.arrays: Dict[LevelFieldArraysHeader.Key, LevelFieldArraysHeader.Value] = {}

    def add_field_array(
        self,
        parent_id: str,
        field: LdtkJson.FieldInstance,
        field_def: LdtkJson.FieldDefinition,
        layer_iid_to_ident: Dict[str, str],
        level_iid_to_ident: Dict[str, str],
    ):
        if not field.type.startswith("Array"):
            return
        parsed = parse_field_type(
            field.type, field_def.can_be_null, field_def.min, field_def.max
        )
        elem_type = LevelFieldArraysHeader.ELEM_TYPE[parsed.field_type]
        match parsed.field_type:
            case (
                "UINT_8_SPAN"
                | "INT_8_SPAN"
                | "UINT_16_SPAN"
                | "INT_16_SPAN"
                | "INT_32_SPAN"
            ):
                int_arr: List[int] = field.value
                value = LevelFieldArraysHeader.Value(
                    elem_type, [str(n) for n in int_arr]
                )
            case "FIXED_SPAN":
                fixed_arr: List[float] = field.value
                value = LevelFieldArraysHeader.Value(
                    elem_type, [f"bn::fixed({n})" for n in fixed_arr]
                )
            case "BOOL_SPAN":
                bool_arr: List[bool] = field.value
                value = LevelFieldArraysHeader.Value(
                    elem_type, [str(f).lower() for f in bool_arr]
                )
            case "STRING_SPAN":
                str_arr: List[str] = field.value
                value = LevelFieldArraysHeader.Value(
                    elem_type, [f'bn::string_view(R"({s})")' for s in str_arr]
                )
            case "COLOR_SPAN":
                color_arr: List[str] = field.value
                value = LevelFieldArraysHeader.Value(
                    elem_type, [str(Color(c)) for c in color_arr]
                )
            case "TYPED_ENUM_SPAN":
                assert parsed.enum_type is not None
                enum_arr: List[str] = field.value
                value = LevelFieldArraysHeader.Value(
                    parsed.enum_type,
                    [f"{parsed.enum_type}::{e}" for e in enum_arr],
                )
            # case "TILE_SPAN":
            #     pass
            case "ENTITY_REF_SPAN":
                entity_ref_arr: Generator[LdtkJson.ReferenceToAnEntityInstance] = (
                    LdtkJson.ReferenceToAnEntityInstance.from_dict(r)
                    for r in field.value
                )
                value = LevelFieldArraysHeader.Value(
                    elem_type,
                    [
                        f"entity_ref(entity_iid::_{r.entity_iid.replace("-", "_")}, layer_ident::{layer_iid_to_ident[r.layer_iid]}, level_ident::{level_iid_to_ident[r.level_iid]})"
                        for r in entity_ref_arr
                    ],
                )
            case "POINT_SPAN":
                point_arr: Generator[LdtkJson.GridPoint] = (
                    LdtkJson.GridPoint.from_dict(p) for p in field.value
                )
                value = LevelFieldArraysHeader.Value(
                    elem_type, [f"bn::point({p.cx}, {p.cy})" for p in point_arr]
                )
            case (
                "OPTIONAL_UINT_8_SPAN"
                | "OPTIONAL_INT_8_SPAN"
                | "OPTIONAL_UINT_16_SPAN"
                | "OPTIONAL_INT_16_SPAN"
                | "OPTIONAL_INT_32_SPAN"
            ):
                opt_int_arr: List[Optional[int]] = field.value
                value = LevelFieldArraysHeader.Value(
                    elem_type,
                    [str(n) if n is not None else "bn::nullopt" for n in opt_int_arr],
                )
            case "OPTIONAL_FIXED_SPAN":
                opt_fixed_arr: List[Optional[float]] = field.value
                value = LevelFieldArraysHeader.Value(
                    elem_type,
                    [
                        f"bn::fixed({n})" if n is not None else "bn::nullopt"
                        for n in opt_fixed_arr
                    ],
                )
            case "OPTIONAL_STRING_SPAN":
                opt_str_arr: List[Optional[str]] = field.value
                value = LevelFieldArraysHeader.Value(
                    elem_type,
                    [
                        (
                            f'bn::string_view(R"({s})")'
                            if s is not None
                            else "bn::nullopt"
                        )
                        for s in opt_str_arr
                    ],
                )
            case "OPTIONAL_TYPED_ENUM_SPAN":
                assert parsed.enum_type is not None
                opt_enum_arr: List[Optional[str]] = field.value
                value = LevelFieldArraysHeader.Value(
                    f"bn::optional<{parsed.enum_type}>",
                    [
                        (
                            f"{parsed.enum_type}::{e}"
                            if e is not None
                            else f"bn::optional<{parsed.enum_type}>()"
                        )
                        for e in opt_enum_arr
                    ],
                )
            # case "OPTIONAL_TILE_SPAN":
            #     pass
            case "OPTIONAL_ENTITY_REF_SPAN":
                opt_entity_ref_arr: Generator[
                    Optional[LdtkJson.ReferenceToAnEntityInstance]
                ] = (
                    (
                        LdtkJson.ReferenceToAnEntityInstance.from_dict(r)
                        if r is not None
                        else None
                    )
                    for r in field.value
                )
                value = LevelFieldArraysHeader.Value(
                    elem_type,
                    [
                        (
                            f"entity_ref(entity_iid::_{r.entity_iid.replace("-", "_")}, layer_ident::{layer_iid_to_ident[r.layer_iid]}, level_ident::{level_iid_to_ident[r.level_iid]})"
                            if r is not None
                            else "bn::nullopt"
                        )
                        for r in opt_entity_ref_arr
                    ],
                )
            case "OPTIONAL_POINT_SPAN":
                opt_point_arr: Generator[Optional[LdtkJson.GridPoint]] = (
                    LdtkJson.GridPoint.from_dict(p) if p is not None else None
                    for p in field.value
                )
                value = LevelFieldArraysHeader.Value(
                    elem_type,
                    [
                        (
                            f"bn::point({p.cx}, {p.cy})"
                            if p is not None
                            else "bn::nullopt"
                        )
                        for p in opt_point_arr
                    ],
                )
            case _:
                raise AssertionError(f"Invalid parsed field type: {parsed.field_type}")

        self.arrays[LevelFieldArraysHeader.Key(parent_id, field.identifier)] = value

    def _write_contents(self, source: TextIOWrapper):
        for key, value in self.arrays.items():
            if len(value.elements) == 0:
                source.write(
                    f"inline constexpr bn::span<const {value.element_type}> gen_priv_{self.parent_type()}_{key.parent_id}_field_{key.field_ident}_array;\n\n"
                )
            else:
                source.write(
                    f"inline constexpr const {value.element_type} gen_priv_{self.parent_type()}_{key.parent_id}_field_{key.field_ident}_array[] {{"
                )
                for i, elem in enumerate(value.elements):
                    if i % 16 == 0:
                        source.write("\n    ")
                    source.write(f"{elem}, ")
                source.write("\n};\n\n")


class LevelLayerInstancesHeader(GenPrivHeader):
    class LayerInfo(NamedTuple):
        layer_ident: str
        tileset_def_idx: Optional[int]
        c_size: Size
        px_total_offset: Point
        has_auto_layer_tiles: bool
        has_grid_tiles: bool
        has_int_grid_csv: bool
        iid: str
        visible: bool

    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_level_layer_instances.h")

    def __init__(self):
        super().__init__()
        self.add_include("ldtk_layer.h")
        self.add_include("ldtk_gen_priv_layer_definitions.h")
        self.add_include("ldtk_gen_priv_tileset_definitions.h")
        self.add_include("ldtk_gen_priv_layer_auto_layer_tiles.h")
        self.add_include("ldtk_gen_priv_layer_entity_instances.h")
        self.add_include("ldtk_gen_priv_layer_grid_tiles.h")
        self.add_include("ldtk_gen_priv_layer_int_grids.h")
        self.add_include("ldtk_gen_idents.h")
        self.add_include("ldtk_gen_iids.h")

        self.layers: Dict[str, List[LevelLayerInstancesHeader.LayerInfo]] = {}
        """Level identifier -> List[LayerInfo]"""

    def add_layers(
        self,
        level_ident: str,
        layers: List[LdtkJson.LayerInstance],
        tileset_infos: TilesetInfos,
    ):
        result: List[LevelLayerInstancesHeader.LayerInfo] = []
        for layer in layers:
            result.append(
                LevelLayerInstancesHeader.LayerInfo(
                    layer.identifier,
                    (
                        tileset_infos.get_tileset_idx(layer.tileset_def_uid)
                        if layer.tileset_def_uid is not None
                        else None
                    ),
                    Size(layer.c_wid, layer.c_hei),
                    Point(layer.px_total_offset_x, layer.px_total_offset_y),
                    len(layer.auto_layer_tiles) != 0,
                    len(layer.grid_tiles) != 0,
                    len(layer.int_grid_csv) != 0,
                    layer.iid.replace("-", "_"),
                    layer.visible,
                )
            )
        self.layers[level_ident] = result

    def _write_contents(self, source: TextIOWrapper):
        for level_ident, layers in self.layers.items():
            if len(layers) == 0:
                source.write(
                    f"inline constexpr bn::span<const layer> gen_priv_level_{level_ident}_layer_instances;\n\n"
                )
            else:
                source.write(
                    f"inline constexpr const layer gen_priv_level_{level_ident}_layer_instances[] {{\n"
                )
                for layer_idx, layer in enumerate(layers):
                    source.write("    layer(\n")
                    source.write(f"        gen_priv_layer_definitions[{layer_idx}],\n")
                    source.write(
                        f"        {f"&gen_priv_tileset_definitions[{layer.tileset_def_idx}]" if layer.tileset_def_idx is not None else "nullptr"},\n"
                    )
                    source.write(f"        {layer.c_size},\n")
                    source.write(f"        {layer.px_total_offset},\n")
                    source.write(
                        f"        {f"&gen_priv_level_{level_ident}_layer_{layer.layer_ident}_auto_layer_tiles" if layer.has_auto_layer_tiles else "nullptr"},\n"
                    )
                    source.write(
                        f"        {f"&gen_priv_level_{level_ident}_layer_{layer.layer_ident}_grid_tiles" if layer.has_grid_tiles else "nullptr"},\n"
                    )
                    source.write(
                        f"        {f"&gen_priv_level_{level_ident}_layer_{layer.layer_ident}_int_grid" if layer.has_int_grid_csv else "nullptr"},\n"
                    )
                    source.write(
                        f"        gen_priv_level_{level_ident}_layer_{layer.layer_ident}_entities,\n"
                    )
                    source.write(f"        layer_iid::_{layer.iid},\n")
                    source.write(f"        {str(layer.visible).lower()}\n")
                    source.write("    ),\n")
                source.write("};\n\n")


class LayerAutoLayerTilesHeader(GenPrivHeader):
    class GridInfo(NamedTuple):
        level_ident: str
        layer_ident: str
        width: int
        height: int

    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_layer_auto_layer_tiles.h")

    def __init__(self):
        super().__init__()
        self.add_include("type_traits", is_system_header=True)
        self.add_include("ldtk_tile_grid_t.h")
        self.add_include(f"ldtk_gen_priv_layer_{self.tiles_type()}_cells.h")

        self.grids: List[LayerAutoLayerTilesHeader.GridInfo] = []

    def add_grid(self, level_ident: str, layer: LdtkJson.LayerInstance):
        self.grids.append(
            LayerAutoLayerTilesHeader.GridInfo(
                level_ident, layer.identifier, layer.c_wid, layer.c_hei
            )
        )

    @staticmethod
    def tiles_type() -> str:
        return "auto_layer_tiles"

    def _write_contents(self, source: TextIOWrapper):
        for grid in self.grids:
            grid_ident = f"gen_priv_level_{grid.level_ident}_layer_{grid.layer_ident}_{self.tiles_type()}"
            cells_ident = grid_ident + "_cells"

            source.write(
                f"inline constexpr const tile_grid_t<sizeof(std::remove_extent_t<decltype({cells_ident})>) >= 2> {grid_ident}(\n"
            )
            source.write(f"    {grid.width},\n")
            source.write(f"    {grid.height},\n")
            source.write(f"    {cells_ident}\n")
            source.write(");\n\n")


class LayerAutoLayerTilesCellsHeader(GenPrivHeader):
    class CellsInfo(NamedTuple):
        level_ident: str
        layer_ident: str
        bloated: bool
        cells: List[int]
        width: int

    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_layer_auto_layer_tiles_cells.h")

    def __init__(self):
        super().__init__()
        self.add_include("cstdint", is_system_header=True)

        self.cells: List[LayerAutoLayerTilesCellsHeader.CellsInfo] = []

    def add_tiles(
        self,
        tiles: List[LdtkJson.TileInstance],
        level_ident: str,
        layer: LdtkJson.LayerInstance,
        tileset_infos: TilesetInfos,
    ):
        assert layer.tileset_def_uid is not None and len(tiles) != 0

        # Determine whether to use `u8` or `u16` for cell storage
        bloated = False
        pre_used_pos: Set[Point] = set()
        for tile in reversed(tiles):
            src = Point(tile.src[0], tile.src[1])
            pos = Point(tile.px[0] // layer.grid_size, tile.px[1] // layer.grid_size)
            if pos not in pre_used_pos:
                pre_used_pos.add(pos)
                tile_idx = tileset_infos.get_tileset_used_tile_idx(
                    layer.tileset_def_uid, src
                )
                if tile_idx >= (1 << 6):
                    bloated = True
                    break

        # Actually parse the cells
        cells: List[int] = [0] * layer.c_wid * layer.c_hei
        for tile in reversed(tiles):
            src = Point(tile.src[0], tile.src[1])
            pos = Point(tile.px[0] // layer.grid_size, tile.px[1] // layer.grid_size)
            # Ignore OOB tile
            if pos.x < 0 or pos.x >= layer.c_wid or pos.y < 0 or pos.y >= layer.c_hei:
                continue
            pos_1 = pos.y * layer.c_wid + pos.x
            if cells[pos_1] == 0:
                cells[pos_1] = 1 + tileset_infos.get_tileset_used_tile_idx(
                    layer.tileset_def_uid, src
                )
                if bloated:
                    assert 1 <= cells[pos_1] < (1 << 14)
                else:
                    assert 1 <= cells[pos_1] < (1 << 6)
                # Apply flipping
                cells[pos_1] |= tile.f << (14 if bloated else 6)

        self.cells.append(
            LayerAutoLayerTilesCellsHeader.CellsInfo(
                level_ident, layer.identifier, bloated, cells, layer.c_wid
            )
        )

    @staticmethod
    def tiles_type() -> str:
        return "auto_layer_tiles"

    def _write_contents(self, source: TextIOWrapper):
        for info in self.cells:
            source.write(
                f"inline constexpr const std::uint{16 if info.bloated else 8}_t gen_priv_level_{info.level_ident}_layer_{info.layer_ident}_{self.tiles_type()}_cells[] {{"
            )
            for i, cell in enumerate(info.cells):
                if i % info.width == 0:
                    source.write("\n    ")
                source.write(f"{cell}, ")
            source.write("\n};\n\n")


class LayerEntityInstancesHeader(GenPrivHeader):
    class Key(NamedTuple):
        level_ident: str
        layer_ident: str

    class EntityInfo(NamedTuple):
        def_idx: int
        grid: Point
        size: Size
        iid: str
        px: Point

    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_layer_entity_instances.h")

    def __init__(self):
        super().__init__()
        self.add_include("ldtk_entity.h")
        self.add_include("ldtk_gen_priv_entity_definitions.h")
        self.add_include("ldtk_gen_priv_layer_entity_field_instances.h")
        self.add_include("ldtk_gen_iids.h")

        self.entities: Dict[
            LayerEntityInstancesHeader.Key, List[LayerEntityInstancesHeader.EntityInfo]
        ] = {}

    def add_entities(
        self,
        level_ident: str,
        layer: LdtkJson.LayerInstance,
        entity_idx_lut: Dict[int, int],
    ):
        result: List[LayerEntityInstancesHeader.EntityInfo] = []
        for entity in layer.entity_instances:
            result.append(
                LayerEntityInstancesHeader.EntityInfo(
                    entity_idx_lut[entity.def_uid],
                    Point(entity.grid[0], entity.grid[1]),
                    Size(entity.width, entity.height),
                    entity.iid.replace("-", "_"),
                    Point(entity.px[0], entity.px[1]),
                )
            )

        self.entities[LayerEntityInstancesHeader.Key(level_ident, layer.identifier)] = (
            result
        )

    def _write_contents(self, source: TextIOWrapper):
        for ident, entities in self.entities.items():
            if len(entities) == 0:
                source.write(
                    f"inline constexpr bn::span<const entity> gen_priv_level_{ident.level_ident}_layer_{ident.layer_ident}_entities;\n\n"
                )
            else:
                source.write(
                    f"inline constexpr const entity gen_priv_level_{ident.level_ident}_layer_{ident.layer_ident}_entities[] {{\n"
                )
                for entity in entities:
                    source.write("    entity(\n")
                    source.write(
                        f"        gen_priv_entity_definitions[{entity.def_idx}],\n"
                    )
                    source.write(f"        {entity.grid},\n")
                    source.write(
                        f"        gen_priv_entity_{entity.iid}_field_instances,\n"
                    )
                    source.write(f"        {entity.size},\n")
                    source.write(f"        entity_iid::_{entity.iid},\n")
                    source.write(f"        {entity.px}\n")
                    source.write("    ),\n")
                source.write("};\n\n")


class LayerEntityFieldInstancesHeader(LevelFieldInstancesHeader):
    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_layer_entity_field_instances.h")

    @staticmethod
    def parent_type() -> str:
        return "entity"

    def __init__(self):
        super().__init__()

        self.entity_ident_lut: Dict[str, str] = {}
        """Entity iid (parent id) -> Entity identifier"""

    def add_entity_iid_identifier_mapping(self, entity_iid: str, entity_ident: str):
        self.entity_ident_lut[entity_iid] = entity_ident

    def _write_definition(self, field_idx: int, parent_id: str, source: TextIOWrapper):
        source.write(
            f"        gen_priv_{self.parent_type()}_{self.entity_ident_lut[parent_id]}_field_definitions[{field_idx}],\n"
        )


class LayerEntityFieldArraysHeader(LevelFieldArraysHeader):
    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_entity_field_arrays.h")

    @staticmethod
    def parent_type() -> str:
        return "entity"


class LayerGridTilesHeader(LayerAutoLayerTilesHeader):
    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_layer_grid_tiles.h")

    def __init__(self):
        super().__init__()

    @staticmethod
    def tiles_type() -> str:
        return "grid_tiles"


class LayerGridTilesCellsHeader(LayerAutoLayerTilesCellsHeader):
    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_layer_grid_tiles_cells.h")

    def __init__(self):
        super().__init__()

    @staticmethod
    def tiles_type() -> str:
        return "grid_tiles"


class LayerIntGridsHeader(GenPrivHeader):
    class GridInfo(NamedTuple):
        level_ident: str
        layer_ident: str
        width: int
        height: int
        is_empty: bool

    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_layer_int_grids.h")

    def __init__(self):
        super().__init__()
        self.add_include("type_traits", is_system_header=True)
        self.add_include("ldtk_int_grid_t.h")
        self.add_include("ldtk_int_grid_empty_t.h")
        self.add_include("ldtk_gen_priv_layer_int_grid_cells.h")

        self.grids: List[LayerIntGridsHeader.GridInfo] = []

    def add_grid(self, level_ident: str, layer: LdtkJson.LayerInstance, is_empty: bool):
        self.grids.append(
            LayerIntGridsHeader.GridInfo(
                level_ident, layer.identifier, layer.c_wid, layer.c_hei, is_empty
            )
        )

    def _write_contents(self, source: TextIOWrapper):
        for grid in self.grids:
            grid_ident = (
                f"gen_priv_level_{grid.level_ident}_layer_{grid.layer_ident}_int_grid"
            )
            cells_ident = grid_ident + "_cells"

            if grid.is_empty:
                source.write(f"inline constexpr const int_grid_empty_t {grid_ident}(\n")
                source.write(f"    {grid.width},\n")
                source.write(f"    {grid.height}\n")
                source.write(");\n\n")
            else:
                source.write(
                    f"inline constexpr const int_grid_t<std::remove_cvref_t<std::remove_extent_t<decltype({cells_ident})>>> {grid_ident}(\n"
                )
                source.write(f"    {grid.width},\n")
                source.write(f"    {grid.height},\n")
                source.write(f"    {cells_ident}\n")
                source.write(");\n\n")


class LayerIntGridCellsHeader(GenPrivHeader):
    class CellsInfo(NamedTuple):
        level_ident: str
        layer_ident: str
        cell_bits: int
        cells: List[int]
        width: int

    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_priv_layer_int_grid_cells.h")

    def __init__(self):
        super().__init__()
        self.add_include("cstdint", is_system_header=True)

        self.grids: List[LayerIntGridCellsHeader.CellsInfo] = []

    def add_cells(self, level_ident: str, layer: LdtkJson.LayerInstance):
        # Determine cell storage type
        max_cell = max(layer.int_grid_csv)
        cell_bits = 32 if max_cell >= (1 << 16) else 16 if max_cell >= (1 << 8) else 8

        # Actually store the cells
        self.grids.append(
            LayerIntGridCellsHeader.CellsInfo(
                level_ident,
                layer.identifier,
                cell_bits,
                layer.int_grid_csv,
                layer.c_wid,
            )
        )

    def _write_contents(self, source: TextIOWrapper):
        for grid in self.grids:
            source.write(
                f"inline constexpr const std::uint{grid.cell_bits}_t gen_priv_level_{grid.level_ident}_layer_{grid.layer_ident}_int_grid_cells[] {{"
            )
            for i, cell in enumerate(grid.cells):
                if i % grid.width == 0:
                    source.write("\n    ")
                source.write(f"{cell}, ")
            source.write("\n};\n\n")


class ProjectHeader(GenHeader):
    @staticmethod
    def base_file_path() -> Path:
        return Path("ldtk_gen_project.h")

    def __init__(self, ldtk_project: LdtkJson.LdtkJSON):
        super().__init__()
        self.add_include("ldtk_project.h")
        self.add_include("ldtk_gen_priv_definitions.h")
        self.add_include("ldtk_gen_priv_levels.h")
        self.add_include("ldtk_gen_iids.h")

        self.iid = ldtk_project.iid.replace("-", "_")
        self.bg_color = Color(ldtk_project.bg_color)
        self.opacity = min(layer.display_opacity for layer in ldtk_project.defs.layers)

    def _write_contents(self, source: TextIOWrapper):
        source.write("inline constexpr const project gen_project(\n")
        source.write(f"    priv::gen_priv_definitions,\n")
        source.write(f"    project_iid::_{self.iid},\n")
        source.write(f"    priv::gen_priv_levels,\n")
        source.write(f"    {self.bg_color},\n")
        source.write(f"    bn::fixed({self.opacity})")
        source.write(");\n")
